---
title: "Week 4: Data visualisation"
subtitle: ""
author: "<large>Charlotte Hadley</large>"
format: 
  revealjs:
    theme: "css/lecture-styles.scss"
    slide-number: "c/t"
bibliography: "../bibtex-file.bib"
csl: "../nature.csl"
cache: true
echo: true
freeze: true
self-contained: true
---

## Topics for today

```{r}
#| echo: false
library(tidyverse)
library(gt)
library(readxl)
library(here)
library(janitor)
library(ggpomological)
library(fontawesome)
library(scales)
library(rnaturalearthdata)
library(sf)
library(gapminder)
gbd_data <- read_csv(here::here("static", "datasets", "data-example_global-burden-of-disease", "data-example_global-burden-of-disease.csv"))
colours_ggplot2_components <- as.list(set_names(ggpomological:::pomological_palette[1:5], c("aesthetics", "geoms", "scales", "guides", "themes")))
```

1. Why do we use charts to tell stories?

1. Evidence-based visual perception theory

1. Advice on choosing charts

1. Advice on using colour in charts

1. Using this advice to tell stories with charts built with `{ggplot2}`

# Why do we use charts?? {background-color="#23241F" .center .center-x}

-----------

> <strike><h1>A picture is worth a thousand words</h1></strike>

-----------

## Data visualisations are demonstrably useful

There is considerable experimental evidence for data visualisations improving:

- Comprehension of data

- Decision making accuracy and confidence

<br>

Evidence has been collected using eye-tracking, survey filling and interviews. 

For a good overview of the available research see Eberhard 2021[@eberhard_effects_2021]. 

> Some of these studies consider tables to be a type of data visualisation.
>
> I agree with this! Tables are often awesome choices for presenting data - let's talk more about this later today.

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

In 1973 Anscombe[@anscombe_graphs_1973] published a paper designed to demonstrate...

> Graphs are essential to good statistical analysis.

To do so he simulated 4 datasets sharing **many** identical statistical properties.

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<img src="images/week-4/anscombe's_quartet_stats.jpg"/>

:::

::::

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

However, if you visualised the datasets it was obvious these datasets were **fundamentally** different to one another.

These charts are now known as *Anscombe's quartet*[@anscombe_graphs_1973].

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<img src="images/week-4/anscombe's_quartet_3.png"/>

:::

::::

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

The "Datasaurus Dozen" is a modern reimagining of the original quartet[@matejka_same_2017].

<br>

Datasaurus was originally created by Alberto Cairo[@cairo_download_2016].

<br>

... there's now an R package for building your own metamers [eliocamp.github.io/metamer/](https://eliocamp.github.io/metamer/)

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}
<br>
<br>
<img src='images/week-4/datasaurus-dozen.gif'/>

:::

::::

-----------

## ALWAYS. {background-color="#23241F" .center .center-x}

### Always visualise your datasets.

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

<img src='images/week-4/cholera-map.jpg'/>

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

There are several historical visualisations that have fundamentally changed social policy and behaviour.

<br>

This is a map from John Snow in 1855[@snow_mode_1855] that ties a cholera outbreak to a specific water pump.

<br>

::: {.fragment}

Combined with Snow's statistical analyses this was a significant step towards the development and acceptance of germ theory.

:::

:::

::::

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

<img src='images/week-4/nightingale-fancy-piecharts.webp'/>

::: {.fragment fragment-index=2}

<img src='images/week-4/nightingale-barchart.webp'/>

:::

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

In exactly the same year, Florence Nightingale[@nightingale_notes_1858] was creating charts to demonstrate the importance of **basic sanitation** in military hospitals.

<br>

::: {.fragment fragment-index=1}

This specific chart is very dramatic and quite rarely used. It's a polar area diagram or a Nightingale rose diagram

:::

<br>

::: {.fragment fragment-index=2}

But it's important to acknowledge that Nightingale used many different types of charts in her work.

Her charts and analyses were central to bringing basic sanitation standards to nursing and hospitals.

:::

:::

::::

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

In 2006 Hans Rosling[@hans_rosling_best_2006] gave [an incredible TED talk where he introduced animated bubble charts](https://www.ted.com/talks/hans_rosling_the_best_stats_you_ve_ever_seen?language=en) as a tool to tell stories about global development.

<br>

These charts helped demonstrate the value of interactive and animated data visualisations - which is why Google bought the tool behind the charts!

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<a href='https://r-graph-gallery.com/271-ggplot2-animated-gif-chart-with-gganimate.html'><img src='images/week-3/gapminder-bubble-chart.png'/></a>
:::

::::

------------

## Data visualisations are demonstrably useful

:::: {.columns}

::: {.column width="48%"}

A more recent example of a very powerful data visualisation is the spiralling global temperature GIF from 2016 by Ed Hawkins [@hawkins_spiralling_2016].

<br>

We can create animated GIF with `{ggplot2}` via the `{gganimate}` package. In fact, Pat Schloss[@pat_schloss_recreating_2022] has a [YouTube video](https://www.youtube.com/watch?v=AYfjdcylAio) and [GitHub repo](https://github.com/riffomonas/climate_viz/tree/95168349ece3c1993e960767a4b4d6124b4abd4a) recreating this chart with R.

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<img src='images/week-4/spiraling-global-temperature-change.gif'/>
:::

::::

# Evidence-based visual perception theory {background-color="#23241F" .center .center-x}

------------

## Evidence-based visual perception theory

There is a wealth of evidence-based research in **how precisely or accurately** charts are perceived by readers.

:::: {.columns}

::: {.column width="48%"}

<center>
<img src='images/week-4/Eyetracker1.jpg'/>
<br>
Source: <a href='https://commons.wikimedia.org/wiki/File:Eyetracker1.jpg'>Wikimedia.org</a>
</center>
:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

Our evidence comes from:

- Eye tracking. We're really good at measuring where the eye is looking, for how long and how intently.

- Asking trial participants to estimate or compare values in charts.

:::

::::

> There are open debates<sup>1</sup> on **how our internal visual perception system works** - what the brain is doing.

::: {.footnote}
<sup>1</sup>A good example is pie charts where we're still not sure what our brains are doing, but we know they're not measuring area thanks to Robert Kosara[@kosara_judgment_2016]
:::

------------

## Elementary perceptual tasks

:::: {.columns}

::: {.column width="48%"}

Back in 1984 Cleveland & McGill[@cleveland_graphical_1984] published their seminal paper on graphical perception theory where they defined "elementary perceptual tasks".

<br>

This study is the backbone of much of the research in this field.

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<img src='images/week-4/cleveland-1984_elementary-perceptual-tasks.jpg'/>

:::

::::

------------

## Elementary perceptual tasks

:::: {.columns}

::: {.column width="48%"}

Cleveland & McGill[@cleveland_graphical_1984] designed many experiments where participants were asked to:

- Identify the largest/smallest segment

- Estimate what % the smaller segment was of the larger segment

The **accuracy** of subject estimates was then statistically analysed.

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

<img src='images/week-4/cleveland-1984_accuracy-comparison.jpg'/>

:::

::::

------------

### Crowd-sourced evidence for perception theory

:::: {.columns}

::: {.column width="48%"}

<img src='images/week-4/cleveland-1984_replication-with-mechanical-turk.jpg' height='500px'/>

:::

::: {.column width="4%"}

:::

::: {.column width="48%"}

Heer & Bostock[@heer_crowdsourcing_2010] replicated this study using Amazon's Mechanical Turk with 3,481 participants in 2010.

<br>

::: {.fragment}

They validated the results of Cleveland & McGill[@cleveland_graphical_1984] and provided further evidence that...

> There is a hierarchy of elementary perceptual tasks - or chart elements - when **accuracy** matters.

:::

:::

::::

------------

### Ordering channels of communication (by accuracy)

:::: {.columns}

::: {.column width="48%" .center-x}

<img src='images/week-4/channel-order_magnitude.jpg' height='500px'/>

:::

::: {.column width="4%"}

:::

::: {.column width="48%" .fragment .center-x}

<img src='images/week-4/channel-order_category.jpg'/>

:::

::::

Images from Beecham et al[@beecham_use_2021]

-----------

#### ... real-world applications of visual perception theory (I)

<img src='images/week-4/encodings-in-detail_bars-and-lines.jpg'/>

Images from Robert Kosara[@kosara_more_2022]

-----------

#### ... real-world applications of visual perception theory (II)

<img src='images/week-4/encodings-in-detail_piecharts.jpg'/>

Images from Robert Kosara[@kosara_more_2022]

-----------

#### ... real-world applications of visual perception theory (III)

<center>
<a href='https://twitter.com/irg_bio/status/1481214254351097859'><img src='images/week-4/seasonality-in-bee-colonies.jpg' height='500px'/></a>
</center>


> Image found on Twitter from <a href='https://twitter.com/irg_bio/status/1481214254351097859'>\@irg_bio</a>[@iker_rivas-gonzalez_irg_bio_i_2022] - code for chart available from [GitHub](https://github.com/rivasiker/TidyTuesday/blob/41f6e460b3024b70f5d87ed09cb7cec226a03fcc/2022/2022-01-11/analysis_2022-01-11.Rmd)[@rivas-gonzalez_seasonality_2022].

# Why is someone <strike>reading</strike> measuring your chart?  {background-color="#23241F" .center .center-x}

-----------

### Why is someone <strike>reading</strike> measuring your chart?

::: {.fragment .fade-in-then-semi-out}

<span class="big-note">To extract accurate values</span>

> The **magnitude** of chart elements.

:::

<hr>

::: {.fragment .fade-in-then-semi-out style="text-align:right"}

<span class="big-note">To quantatively compare values.</span>

> The **part to whole** or **relative magnitude** of chart elements.

:::

<hr>

::: {.fragment .fade-in-then-semi-out}

<span class="big-note">To find the largest/smallest value.</span>

> The **ranking** of chart elements

:::

<hr>

::: {.fragment .fade-in-then-semi-out style="text-align:right"}

<span class="big-note">To find *unusual* values.</span>

> The **distribution**, **ranking** or **magnitude** of chart elements

:::

-----------

### Why is someone reading your chart?

::: {.fragment .fade-in-then-semi-out}

<span class="big-note">You have a story you want to tell</span>

> There's lots we can do to help guide the reader to understand your chart and follow the story you're telling. We'll cover some examples during this course.


:::

<hr>

::: {.fragment .fade-in-then-semi-out style="text-align:right"}

<span class="big-note">The reader wants to see the data</span>

> Charts (and tables) are the best way to see the "big picture" of a dataset - a single value (eg mean) is kind of useless. Interactivity is really useful to allow readers to properly **explore** the dataset.

:::

<hr>

::: {.fragment .fade-in-then-semi-out}

<span class="big-note">The reader has a preconception about the data</span>

> Readers might be approaching a chart biased with a particular theory about the data. We can do our best to make our charts easy to read and avoid common pitfalls.

:::

# How do we choose a chart? {background-color="#23241F" .center .center-x}

-----------

:::: {.columns .center}

::: {.column width='48%' .center-x}
### Use data columns to choose charts

<img src='images/week-4/screenshot-msleep.jpg'/>
:::


::: {.column width='4%'}
:::

::: {.column width='48%' .center-x}
### Use your story to choose charts

<img src='images/week-4/ft-visual-vocab_square.png' height='300px'/>
:::

::::

-----------

## [data-to-viz.com](https://www.data-to-viz.com/)

::: {.center-x}
<a href='https://www.data-to-viz.com/'/><img src='images/week-4/screenshot_data-to-viz.jpg' height='400px'/></a>
:::

> This site also provides simple to follow instructions for using {ggplot2} to build every single chart type you can find on the website.

-----------

## [ft-interactive.github.io/visual-vocabulary](https://ft-interactive.github.io/visual-vocabulary/)

:::: {.columns}

::: {.column width='60%'}
<a href='https://ft-interactive.github.io/visual-vocabulary/'/><img src='images/week-4/ft-visual-vocab_poster.png' height='450px'/></a>
:::

::: {.column width='40%'}
<img src='images/week-4/ft_ggplot2-as-a-creativity-engine.jpg' height='450px'/>
:::

::::

> The Visual Vocabulary is a really useful tool for thinking about how to tell your story with a chart.
>
> Lots of the dataviz at the FT is done with R. John Burn-Murdoch[@burn-murdoch_ggplot2_2016] is a great source to follow.

# {ggplot2} for charts {background-color="#23241F" .center .center-x}

-----------

## `r emo::ji("memo")` Task: Setup a new project {background-color="#def3f7"}
<p class='task-slide-count'>SLIDE 1 OF 3</p>

1. Create a new project called something like `week-4_dataviz.Rproj`

1. Add a new RMarkdown document called `ggplot2-notes.Rmd`

> We're going to do some structured and unstructured code during today. During the workshop I'll be asking to you to create your own charts.

-----------

## ggplot2: A Grammar of Graphics

`{ggplot2}` is an incredibly powerful and flexible tool for building static dataviz.

We can build (almost)<sup>1</sup> **any** static chart we can conceive of.

 
```{r, echo=FALSE, fig.height=3.8, fig.width=10, message=FALSE, warning=FALSE, dpi=150, cache=TRUE}
#| echo: false
#| fig.height: 3.8
#| fig.width: 10
#| message: false
#| warning: false
#| dpi: 150
library("tidyverse")
library("lubridate")
library("patchwork")
library("fivethirtyeight")

gg_iris_scatter <- iris %>%
  ggplot(aes(x = Petal.Length,
             y = Sepal.Length)) +
  geom_point() +
  labs(x = "", y = "") +
  theme_bw()

gg_economics_line <- economics_long %>%
  ggplot() +
  geom_line(aes(date, value01, colour = variable), show.legend = FALSE) +
  labs(x = "", y = "") +
  theme_bw()


gg_marital_bar <- gss_cat %>%
  count(marital) %>%
  mutate(
    marital = fct_anon(marital, prefix = "type "),
    marital = fct_reorder(marital, n)) %>%
  ggplot() +
  geom_col(aes(x = marital, y = n)) +
  coord_flip() +
  labs(x = "", y = "") +
  theme_bw()

mtlong <- reshape2::melt(mtcars)


gg_quakes_histogram <- ggplot(quakes) +
  geom_histogram(aes(x = mag)) +
  labs(x = "", y = "") +
  theme_bw()

gg_bechden_violin <- bechdel %>%
  filter(domgross_2013 < 1e9) %>%
  # filter(domgross_2013 >= 1e6) %>%
  ggplot() +
  geom_violin(aes(x = clean_test,
                  y = domgross_2013),
              fill = "orange") +
  coord_flip() +
  labs(x = "", y = "") +
  theme_bw()

gg_diamonds_histogram <- ggplot(mtlong, aes(value)) + facet_wrap(~variable, scales = 'free_x') +
  geom_histogram(binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3))) +
  labs(x = "", y = "") +
  theme_bw()
# ggsave("gg-saves/gg-iris-scatter.png",
#        gg_iris_scatter)
# ggsave("gg-saves/gg-economics-line.png",
#        gg_economics_line)

bump_data <- tribble(
  ~response, ~year, ~within_year_rank,
  "Yes", 2019, 1,
  "Maybe", 2019, 2,
  "No", 2019, 3,
  "Unsure", 2019, 4,
  "Unsure", 2016, 1,
  "No", 2016, 2,
  "Maybe", 2016, 3,
  "Yes", 2016, 4,
  "Yes", 2017, 3,
  "No", 2017, 2,
  "Unsure", 2017, 1,
  "Maybe", 2017, 4,
  "No", 2018, 1,
  "Yes", 2018, 2,
  "Maybe", 2018, 4,
  "Unsure", 2018, 3
)
gg_bump <- bump_data %>%
  ggplot(aes(x = year, y = within_year_rank, group = response)) +
    geom_line(aes(color = response), size = 2) +
    geom_point(aes(color = response), size = 4) +
    geom_point(color = "#FFFFFF", size = 1) +
    scale_y_reverse(breaks = 1:nrow(bump_data)) +
    scale_x_continuous(breaks = unique(bump_data$year), minor_breaks = unique(bump_data$year)) +
  coord_cartesian(ylim = c(1, length(unique(bump_data$response)))) +
  theme_bw() +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank()) +
  labs(x = "", y = "") 


gg_iris_scatter + gg_economics_line + gg_marital_bar + plot_layout(ncol = 3) + 
  gg_quakes_histogram + gg_bechden_violin + gg_bump

```

> [1] - Dual y-axis charts must be transformations of one another ([for good reasons](https://stackoverflow.com/a/3101876/1659890))

-----------

:::: {.columns .v-center-container}

::: {.column width="48%"}

### Building blocks of a {ggplot2} chart

:::

::: {.column width="4%"}

:::

::: {.column width="48%" style="padding-top:60px"}

<div style="border-left:1px black solid;border-bottom:1px black solid;padding-bottom:35px;padding-top:35px;padding-left:20px;font-size:35px" layout-valign="bottom">

`r fontawesome::fa(name = "ruler-combined", fill = colours_ggplot2_components$aesthetics)` <span style='color:`r colours_ggplot2_components$aesthetics`'>Aesthetics</span>

</div>

<div style="border-left:1px black solid;border-bottom:1px black solid;padding-bottom:35px;padding-top:35px;padding-left:20px;font-size:35px" layout-valign="bottom">

`r fontawesome::fa(name = "shapes", fill = colours_ggplot2_components$geoms)` <span style='color:`r colours_ggplot2_components$geoms`'>Geoms</span>

</div>

<div style="border-left:1px black solid;border-bottom:1px black solid;padding-bottom:35px;padding-top:35px;padding-left:20px;font-size:35px" layout-valign="bottom">

`r fontawesome::fa(name = "scale-balanced", fill = colours_ggplot2_components$scales)` <span style='color:`r colours_ggplot2_components$scales`'>Scales</span>

</div>

<div style="border-left:1px black solid;border-bottom:1px black solid;padding-bottom:35px;padding-top:35px;padding-left:20px;font-size:35px" layout-valign="bottom">

`r fontawesome::fa(name = "tags", fill = colours_ggplot2_components$guides)` <span style='color:`r colours_ggplot2_components$guides`'>Guides</span>

</div>

<div style="border-left:1px black solid;padding-bottom:35px;padding-top:35px;padding-left:20px;font-size:35px" layout-valign="bottom">

`r fontawesome::fa(name = "paint-roller", fill = colours_ggplot2_components$themes)` <span style='color:`r colours_ggplot2_components$themes`'>Theme</span>

</div>

:::

::::

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "ruler-combined", fill = colours_ggplot2_components$aesthetics)` <span style='color:`r colours_ggplot2_components$aesthetics`'>Aesthetics</span>

:::

::: {.column width="60%"}

Aesthetics are used to create **mappings** between <ins>columns in our datasets</ins> and the <ins>coordinate systems</ins> of our chart:

<br>

```{r}
#| eval: false
msleep %>% 
  ggplot() +
  aes(
    x = sleep_total,
    y = sleep_rem,
    colour = vore
  )
```

<br>

::: {.fragment}

`{ggplot2}` uses *tidy evaluation* to allow us to use bare column names in our code.

:::

:::

::::

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "ruler-combined", fill = colours_ggplot2_components$aesthetics)` <span style='color:`r colours_ggplot2_components$aesthetics`'>Aesthetics</span>

:::

::: {.column width="60%"}

| Where is aes() placed? | What it does |
| :-- | :-- | 
| Inside `ggplot()` or on its own | Sets the aesthetics for the entire {ggplot2} object.<br><br> These could be considered the *coordinate system aes()* |
| Inside `geom_*()` | Sets aesthetics for a specific geom *within* the existing coordinate system aes() for the {ggplot2} object.<br><br> These should be considered *geom specific aes()* |


:::

::::

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "shapes", fill = colours_ggplot2_components$geoms)` <span style='color:`r colours_ggplot2_components$geoms`'>Geoms</span>

:::

::: {.column width="60%"}

Geoms use the aesthetics to add layers to our charts.

```{r}
#| eval: false
msleep %>% 
  ggplot() +
  aes(
    x = sleep_total,
    y = sleep_rem,
    colour = vore
  ) +
  geom_point()
```

<br>

There are 50+ geoms baked into the `{ggplot2}` package.

::: {.small style='font-size:50%'}
`geom_abline()`, `geom_area()`, `geom_bar()`, `geom_bin2d()`, `geom_blank()`, `geom_boxplot()`, `geom_col()`, `geom_contour()`, `geom_contour_filled()`, `geom_count()`, `geom_crossbar()`, `geom_curve()`, `geom_density()`,  `geom_density_2d()`, `geom_density_2d_filled()`, `geom_density2d()`, `geom_density2d_filled()`, `geom_dotplot()`, `geom_errorbar()`, `geom_errorbarh()`, `geom_freqpoly()`, `geom_function()`, `geom_hex()`, `geom_histogram()`, `geom_hline()`, `geom_jitter()`, `geom_label()`, `geom_line()`, `geom_linerange()`, `geom_map()`, `geom_path()`, `geom_point()`, `geom_pointrange()`, `geom_polygon()`, `geom_qq()`, `geom_qq_line()`, `geom_quantile()`, `geom_raster()`, `geom_rect()`, `geom_ribbon()`, `geom_rug()`, `geom_segment()`, `geom_sf()`, `geom_sf_label()`, `geom_sf_text()`, `geom_smooth()`, `geom_spoke()`, `geom_step()`, `geom_text()`, `geom_tile()`, `geom_violin()`, `geom_vline()`

:::

<br>

As we'll see later, there are *many* `{ggplot2}` extension packages that add **even more** geoms to the mix.

:::

::::

-----------

## Some geoms are built from others (I)

:::: {.columns}

::: {.column width='48%'}
`geom_histogram()` has clever tricks to make useful histograms


```{r, eval=FALSE}
ggplot(quakes, aes(mag)) +
  geom_histogram()
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='300px'}
ggplot(quakes, aes(mag)) +
  geom_histogram() +
  theme_gray(base_size = 25)
```
:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
It's built by calling `geom_bar()`

```{r, eval=FALSE}
ggplot(quakes, aes(mag)) +
  geom_bar() +
  scale_x_binned()
```

```{r, echo=FALSE, message=FALSE, warning=FALSE, out.width='350px'}
ggplot(quakes, aes(mag)) +
  geom_bar() +
  scale_x_binned() +
  theme_gray(base_size = 25)
```

:::

::::

-----------

## Some geoms are built from others (II)

But `geom_bar()` itself is built from `geom_rect()`.

```{r, echo=TRUE}
#| output-location: column
rect_data <- tribble(
  ~x_min, ~x_max, ~y_min, ~y_max,
  4, 4.48, 0, 60,
  4.5, 5.48, 0, 100,
  5.5, 5.98, 0, 10
)
rect_data %>% 
  ggplot() +
  geom_rect(aes(xmin = x_min, 
                xmax = x_max, 
                ymin = y_min, 
                ymax = y_max)) +
    theme_gray(base_size = 25)
```
<br>

> There are **8 primitives** from which all other geoms are built: 

`geom_blank()`, `geom_path()`, `geom_point()`, `geom_polygon()`, `geom_rect()`, `geom_ribbon()`, `geom_segment()`, `geom_text()`

-----------

## All geoms have `x` and `y` aesthetics

These tell the geom where it needs to be drawn:

```{r}
#| output-location: column
starwars %>% 
  ggplot() +
  aes(x = height,
      y = mass) +
  geom_point()
```

-----------

### Some geoms need more than just `x` and `y`

Let's `geom_segment()` to visualise some of the eras of the dinosaurs:

```{r}
dinosaurs <- tribble(
  ~period, ~start, ~end,
  "Triassic Period", -251e6, -225e6,
  "Late Triassic Period", -225e6, -200e6,
  "Jurassic Period", -200e6, -150e6,
  "Late Jurassic Period", -150e6, -145e6
)
```

To build this chart we need to specify **all** of the following: x, xend, y and yend.

-----------

### Use `size` to affect geom size

In many charts we want geoms to be **thicker**, **bigger** or *just be more prominent*. 

Timeline (or Gantt charts) are good examples of this. We want the segments to be thicker to improve the readability of the chart - this comes down to the `size` aesthetic.

```{r plot-dinosaur-timeline}
dinosaurs %>% 
  ggplot() +
  aes(x = start, xend = end,
      y = period, yend = period) +
  geom_segment(size = 30)
```

-----------

## Out of order dinosaurs

```{r}
#| echo: false
dinosaurs %>% 
  ggplot() +
  aes(x = start, xend = end,
      y = period, yend = period) +
  geom_segment(size = 30)
```

This is still a **bad chart**.

The eras are not ordered in geological time, instead they're ordered (reverse) alphabetically.

To control the order of things in `{ggplot2}` charts we must use **factors** - which are picked up by the **scales**.

-----------

## Some geoms are designed to save time

:::: {.columns}

::: {.column width='48%'}
`geom_bar()` defaults to counting instances of a variable.

```{r plot-geom-bar}
mpg %>% 
  count(manufacturer) %>% 
  ggplot() +
  geom_bar(aes(manufacturer))
```
:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
`geom_col()` uses a column to dictate the length of bars.

```{r plot-geom-col}
mpg %>% 
  count(manufacturer) %>% 
  ggplot() +
  geom_col(aes(x = manufacturer, y = n))
```
:::

::::

-----------

## Some geoms depend on `stat` functions

The `geom_bar()` function has a `stat` argument with the default value of `"count"`.

We can force the geom to behave like `geom_col()` by changing the stat:

```{r}
#| output-location: column
mpg %>% 
  count(manufacturer) %>% 
  ggplot() +
  geom_bar(aes(x = manufacturer,
               y = n),
           stat = "identity")
```

<br>

All of the goodness from the `stat` argument comes from the `stat_identity()` and `stat_count()` functions. 

If you're building a complex chart it might be useful to directly call a [stat_() function](https://ggplot2.tidyverse.org/reference/#section-stats).

-----------

## Position things to resolve overlapping (I)

Box and whisker diagrams hide a lot of detail

```{r}
#| output-location: column
bechdel %>% 
  filter(complete.cases(.),
         domgross_2013 < 0.5e9) %>% 
  ggplot(aes(clean_test, 
             domgross_2013)) +
  geom_boxplot() +
  theme_gray(base_size = 25)
```


Let's add the data points to this chart with `geom_point()` and look at the position argument.

-----------

## Position things to resolve overlapping (II)

The position argument can also be used to create three different types of bar chart:

- "stack" creates a stacked bar chart

- "fill" creates a proportional bar chart

- "dodge" creates a grouped bar chart

Let's create all 3 of these for the following dataset:

```{r}
gss_cat %>% 
  count(relig, marital)
```

-----------

## Geom layers are placed on top of one another

```{r plot-mpg-spline-fit}
#| output-location: column
ggplot(mpg, 
       aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = lm, 
              formula = y ~ splines::bs(x, 3),
              size = 5)
```

The `geom_smooth()` line is hiding data points.

We could either swap the order of these geoms or change the `alpha` aesthetic.

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "scale-balanced", fill = colours_ggplot2_components$scales)` <span style='color:`r colours_ggplot2_components$scales`'>Scales</span>

:::

::: {.column width="60%"}

Scales determine the appearance of an aesthetic within the chart, including:

- Axes labels and breaks

- Colours used for `colour` and `fill` aesthetics

```{r}
#| eval: false
msleep %>% 
  ggplot() +
  aes(
    x = sleep_total,
    y = sleep_rem,
    colour = vore
  ) +
  geom_point() +
  scale_colour_manual(
    values = c("carni" = "#c03728", 
               "omni" = "#fd8f24", 
               "insecti" = "#f5c04a", 
               "herbi" = "#919c4c", 
               "NA" = "#e68c7c")
  )
```

<br>

Scales also determine the **order** in which elements are shown in a chart.

To change the order of discrete/categorical columns we need to use **factors**.

:::

::::

-----------

## Scales and {scales}

{ggplot2} uses the {scales} package under the hood to build all of the scales that we see - including continuous and discrete scales.

<br>

The `{scales}` package also contains many utility functions that are useful for us to format our axes and other scales.

<br>

We can either load the `{scales}` package itself or call functions specifically with `scales::label_percent()`

-----------

## {scales} and deprecation (I)

Until recently the way we'd use `{scales}` would be as follows

:::: {.columns}

::: {.column width='48%'}
```{r, include=TRUE}
percent(c(0.3, 0.5, 0.6))
```

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
```{r}
msleep %>% 
  mutate(sleep_perc = sleep_total / 24,
         sleep_rem_perc = sleep_rem / 24) %>% 
  ggplot() +
  aes(x = sleep_perc,
      y = sleep_rem_perc) +
  geom_point() +
  scale_x_continuous(label = percent_format()) +
  theme_gray(base_size = 24)
```

:::

::::

There was a function called `percent(x)` for formatting a vector of values `x` and `percent_format()` for modifying the appearance of percentages in a {ggplot2} chart.

-----------

## {scales} and deprecation (II)

These functions have now been deprecated. This means there are new alternatives to these functions.

<br>

Deprecation is a fact of life in software development. But the details of how things are deprecated are variable.

<br>

Sometimes things are deprecated with the intention of removing them in the future. Other times, the deprecated functions will continue to exist far into the future.

<br>

It seems like the intention is for these functions to continue to work into the future. But they might be removed in several years time.

> Let's use the new approach for formatting scales so that you can read modern documentation and so you're not learning deprecated functions.

-----------

## {scales} and deprecation (III)

We now use `label_percent()` for both types of operation.

:::: {.columns}

::: {.column width='48%'}
```{r, include=TRUE}
label_percent()(c(0.3, 0.5, 0.6))
```

::: {.fragment}

> This is known as a function factory.
>
> Function factories are cool. But I wish you didn't have to learn this syntax.

:::

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
```{r}
msleep %>% 
  mutate(sleep_perc = sleep_total / 24,
         sleep_rem_perc = sleep_rem / 24) %>% 
  ggplot() +
  aes(x = sleep_perc,
      y = sleep_rem_perc) +
  geom_point() +
  scale_x_continuous(label = label_percent()) +
  theme_gray(base_size = 24)
```

:::

::::

-----------

## {scales} and colours (I)

There are many built-in colour palettes in {scales} - let me introduce two families of palettes.

:::: {.columns}

::: {.column width='48%'}
The website [colorbrewer2.org](https://colorbrewer2.org) contains several palettes differentiated into sequential, diverging and qualitative.

```{r}
msleep %>% 
  count(conservation) %>% 
  ggplot() +
  aes(x = n,
      y = conservation,
      fill = conservation) +
  geom_col() +
  scale_fill_brewer(palette = "Set2")
```

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
:::

::::

-----------

## {scales} and colours (II)

There are many built-in colour palettes in {scales} - let me introduce two families of palettes.

:::: {.columns}

::: {.column width='48%'}

```{r, echo=FALSE}
msleep %>% 
  count(conservation) %>% 
  ggplot() +
  aes(x = n,
      y = conservation,
      fill = conservation) +
  geom_col() +
  scale_fill_brewer(palette = "Set2")
```

There are some pretty good palettes for discrete/categorical variables in this family of palettes.

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
:::

::::

-----------

## {scales} and colours (III)

There are many built-in colour palettes in {scales} - let me introduce two families of palettes.

:::: {.columns}

::: {.column width='48%' .de-emphasis}

```{r, echo=FALSE}
msleep %>% 
  count(conservation) %>% 
  ggplot() +
  aes(x = n,
      y = conservation,
      fill = conservation) +
  geom_col() +
  scale_fill_brewer(palette = "Set2")
```

There are some pretty good palettes for discrete/categorical variables in this family of palettes.

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}

But for continuous variables I strongly recommend using the [viridis family of palettes](https://ggplot2.tidyverse.org/reference/scale_viridis.html).

These are designed to be both perceptually uniform and to work for folks with colour blindness.

```{r}
countries110 %>% 
  st_as_sf() %>% 
  left_join(filter(gapminder, year == 2007),
            by = c("name" = "country")) %>% 
  ggplot() +
  geom_sf(aes(fill = lifeExp)) +
  scale_fill_viridis_c()

```


:::

::::

-----------

## Setting custom colours (I)

One of the first frustrations people find with {ggplot2} is setting our own custom colours, eg in this chart:

```{r}
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col()
```

-----------

## Setting custom colours (II)

We need to use `scale_fill_manual()`

```{r}
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col() +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"))
```

We'll come back to this chart in the section on guides().

-----------

## {scales} and factors (I)

Factors are R's categorical data type. They allow us to create a variable with fixed values (`levels`) and to set the *order* of those levels.

Let's look at a pre-existing dataset with factors:

```{r}
gss_cat %>% 
  head() %>% 
  pull(rincome)
```

<br>

```{r}
#| output-location: column-fragment
gss_cat %>% 
  count(rincome) %>% 
  ggplot() +
  aes(x = n,
      y = rincome) +
  geom_col() +
  theme_gray(base_size = 24)
```

-----------

## {scales} and factors (II)

The base R tools for creating and manipulating factors are messy and frustrating to use.

We're going to use the {forcats} package which is loaded when we run `library(tidyverse)`.

Almost all of the functions begin with `fct_*()` to let you know we're dealing with factors.

-----------

## factors and msleep

Let's think of the different ways we could order this dataset:

```{r}
msleep %>% 
  count(vore)
```

:::: {.columns}

::: {.column width='48%'}
**Count order**

::: {.fragment fragment-index=1 .fade-in-then-semi-out}

In this ordering we will arrange the `vore` column according to values in the `n` column.

<br>

This is usually what we want in count bar charts.

:::

:::

::: {.column width='4%'}
:::

::: {.column width='48%'}
**Canonical order**

::: {.fragment fragment-index=2}

In this ordering we'll arrange the `vore` column from the diet with the most meat to the least meat.

<br>

This is usually what we want in visualising survey datasets, 

- eg Strong disagree, Disagree, Neither agree or disagree, Agree, Strong Agree

:::

:::

::::

-----------

## msleep factor: count order (I)

We use `fct_reorder()` to order a factor by another column.

```{r}
#| output-location: column
msleep %>% 
  count(vore) %>% 
  mutate(vore = fct_reorder(vore, n)) %>% 
  ggplot() +
  aes(x = n,
      y = vore) +
  geom_col() +
  theme_gray(base_size = 24)
```

But what about the `NA` values? What should we do?

-----------

## msleep factor: count order (II)

We can replace NA values nicely with `fct_explicit_na()`

```{r}
#| output-location: column
msleep %>% 
  count(vore) %>% 
  mutate(vore = fct_reorder(vore, n),
         vore = fct_explicit_na(vore, "Unknown diet")) %>% 
  ggplot() +
  aes(x = n,
      y = vore) +
  geom_col() +
  theme_gray(base_size = 24)
```

> Let's come back to moving the position of the NA level.

-----------

## msleep factor: canonical order (I)

To set our own canonical order we use `fct_relevel()` and provide a vector with our preferred order.

```{r}
#| output-location: column
order_vore <- c("carni", "omni", "insecti", "herbi")

msleep %>% 
  count(vore) %>% 
  mutate(vore = fct_relevel(vore, order_vore),
         vore = fct_rev(vore)) %>% 
  ggplot() +
  aes(x = n,
      y = vore) +
  geom_col() +
  theme_gray(base_size = 24)
```

-----------

## msleep factor: canonical order (II)

We can also use `fct_relevel()` to modify the position of a specific 

```{r}
#| output-location: column
msleep %>% 
  count(vore) %>% 
  mutate(vore = fct_relevel(vore, order_vore),
         vore = fct_rev(vore),
         vore = fct_explicit_na(vore, "Unknown diet"),
         vore = fct_relevel(vore, "Unknown diet", after = 0)) %>% 
  ggplot() +
  aes(x = n,
      y = vore) +
  geom_col() +
  theme_gray(base_size = 24)
```


-----------

### `r emo::ji("memo")` Task: Global Burden of Disease factors {background-color="#def3f7"}
<p class='task-slide-count'>SLIDE 1 OF 3</p>

> These are the same steps you've repeated before

1. Add a sub-folder to your project called `data`

1. Inside of the `data` folder add a script called `obtain-data.R`

1. Add this code

```{r, eval=FALSE}
download.file("https://raw.githubusercontent.com/charliejhadley/eng7218_data-science-for-healthcare-applications_bcu-masters/main/static/datasets/data-example_global-burden-of-disease/data-example_global-burden-of-disease.csv",
              destfile = "data/global-burden-of-disease-data.csv")
```

5\. Run the code

-----------

### `r emo::ji("memo")` Task: Global Burden of Disease factors {background-color="#def3f7"}
<p class='task-slide-count'>SLIDE 2 OF 3</p>

1\. Add a new heading for the GBD Dataset to your .Rmd

2\. Filter the dataset as follows:

- Most recent year
  
- `location_name` starts with "World Bank"
  
- `metric_name` is "Number"
  
- `cause_name` is "Injuries"

3\. Select only these columns

  - `location_name`, `cause_name`, `val`

-----------

### `r emo::ji("memo")` Task: Global Burden of Disease factors {background-color="#def3f7"}
<p class='task-slide-count'>SLIDE 2 OF 3</p>

```{r}
#| include: false
gdb_injuries <- gbd_data %>% 
  filter(str_starts(location_name, "World Bank"),
         year == max(year),
         measure_name == "Deaths",
         metric_name == "Number",
         cause_name == "Injuries") %>% 
  select(location_name, cause_name, val)
```

Create two versions of this chart:

- Bars are ordered by their size

- Bars are ordered from "World Bank High Income" to "World Bank Low Income"

```{r}
#| output-location: column
gdb_injuries %>% 
  ggplot() +
  aes(x = val,
      y = location_name) +
  geom_col() +
  theme_gray(base_size = 24)
```

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "tags", fill = colours_ggplot2_components$guides)` <span style='color:`r colours_ggplot2_components$guides`'>Guides</span>

:::

::: {.column width="60%"}

We (kind of) use "guides" and "legends" interchangeably in `{ggplot2}`.

```{r}
#| eval: false
ggplot() +
  geom_line(show.legend = FALSE) +
  guides(alpha = guide_legend()) +
  theme(legend.position = "bottom")
```

Guides can **only** be created through a corresponding aesthetic and scale.

```{r}
#| echo: false
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col() +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"),
                    name = "")
```


:::

::::

-----------

## "Manual legends" (I)

Sometimes we want to add additional legend items - usually for NA values, and particularly for maps.

Let's continue with this chart from before:

```{r}
#| output-location: column
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", 
                    "No meat", 
                    "Some meat")) +
  geom_col() +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"),
                    name = "")
```

-----------

## "Manual legends" (II)

We need to choose an aesthetic that works for `geom_col()` but we're not using elsewhere in the chart.

This will change depending on your chart. In this instance we can use `size`

```{r}
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col(aes(size = "Unknown diet")) +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"),
                    name = "")
```

-----------

## "Manual legends" (III)

We now set the `na.value` colour for the original `scale_fill_manual()` scale

```{r}
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col(aes(size = "Unknown diet")) +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"),
                    name = "",
                    na.value = "blue")
```

-----------

## "Manual legends" (IV)

Next we use the `guides()` function to override the values for the `size` legend

```{r}
msleep %>% 
  count(vore) %>% 
  ggplot() +
  aes(x = n,
      y = vore,
      fill = ifelse(vore == "herbi", "No meat", "Some meat")) +
  geom_col(aes(size = "Unknown diet")) +
  scale_fill_manual(values = c("Some meat" = "red",
                               "No meat" = "darkgreen"),
                    name = "",
                    na.value = "blue") +
  guides(size = guide_legend(title = "",
                             override.aes = list(fill = "blue")))
```

-----------

## More about guides()

If we want to modify the size of legend items we have two choices:

- `guides(fill = guide_colourbar(barwidth = 0.5, barheight = 10))`

- ... or to set the sizes in the `theme()`.

-----------

:::: {.columns .v-center-container}

::: {.column width="40%"}

### `r fontawesome::fa(name = "paint-roller", fill = colours_ggplot2_components$theme)` <span style='color:`r colours_ggplot2_components$theme`'>Theme</span>

:::

::: {.column width="60%"}

There are over 92 arguments to the theme() function for controlling chart appearance.

<br>

Remembering them all is challenging - I usually google them! Or use guides like this one:

<img src='images/week-4/ggplot2-theme-elements.png'/>
<span class="small">Source: https://bookdown.org/alapo/learnr/data-visualisation.html</span>

:::

::::

-----------

## What themes are there? (I)

{ggplot2} has several built-in themes. They have several arguments for quickly customising them.

I've been using the default `theme_gray()` to change text size in charts.

```{r}
msleep %>% 
  mutate(sleep_perc = sleep_total / 24,
         sleep_rem_perc = sleep_rem / 24) %>% 
  ggplot() +
  aes(x = sleep_perc,
      y = sleep_rem_perc) +
  geom_point() +
  scale_x_continuous(label = label_percent()) +
  theme_gray(base_size = 24)
```

-----------

## What themes are there? (II)

The {ggthemes} package contains lots of really useful - and beautiful - themes.

It's recommended that you choose a theme close to what to want and then customise it.

```{r}
#| eval: false
theme_fivethirtyeight() +
  theme(panel.grid.major = element_line(colour = "red"))
```

-----------

## element_*() functions in legends

Most of the legend arguments expect one of these functions:

- element_line()

- element_text()

- element_rect()

Or `element_black()` if you want to remove a theme element.

::: {.notes}

- Some rules to follow:

  - Don't use pies for more than a few groups (ideally 2)
  
  - If using bubble charts vary by area instead of radius
  
  - Colour schemes matter A LOT

- Dataviz are demonstrably awesome

- Visual Perception Theory

- Let's make some actual ggplot2 charts / Grammar of Graphics

- Deciding on charts (FT Visual Vocabulary)

- Things to avoid / Advice (does this belong in visual perception theory?)

  - Starting at zero

  - Lots of different types of charts
  
  - Dynamite charts

- Sucking quote 

>  “There is no way of knowing nothing about a subject to knowing something about a subject without going through a period of much frustration and suckiness.”
“Push through. You’ll suck less.” Hadley Wickham, author of ggplot2

- Tables

  - Better than just text
  - But can be overwhelming
    - See doi.org/10.1017/S1537592707072209 for excellent examples
  - Using sparklines can really help

:::

-----------

### References

::: {#refs}
:::

